package com.mchange.sc.v1.consuela.ethereum.jsonrpc

import scala.collection._
import play.api.libs.json._
import com.mchange.sc.v2.playjson._

final object TightAbi {

  /*
   *  The defaults here are meant to fill in for attributes not emitted by earlier versions of the solidity compiler.
   * 
   *  In older versions, all functions were payable, so that defaults to true.
   *                     there were no anonymous events, so that defaults to false.
   * 
   *  Note that "payable" would more sensibly default to false, and indeed it does in newer compilers, 
   *  which emit payable as false.
   * 
   *  But ABI generated by older compilers always omitted the (then-undefined) modifier, and the behavior was to
   *  always accept payment. So our default, if no payable field is present, is to consider "payable" true, so that
   *  we do not alter or break behavior when we read and then rewrite ABI.
   */              
  private val DefaultTrue  = Some( JsBoolean( true ) )
  private val DefaultFalse = Some( JsBoolean( false ) )

  private val DefaultPayable = Some( JsString( "payable" ) )

  private def restrictTransformAbiXxxParameterValue( parentName : String, nonTypeParams : Map[String,Option[JsValue]] )( jsv : JsValue ) : JsResult[JsObject] = {
    jsv match {
      case jso : JsObject => restrictTransformAbiXxxParameterObject( parentName, nonTypeParams)( jso )
      case oops           => JsError( s"An abi ${parentName} parameter must be a JsObject, found $oops" )
    }
  }

  private def restrictTransformAbiXxxParameterObject( parentName : String, nonTypeParams : Map[String,Option[JsValue]] )( jso : JsObject ) : JsResult[JsObject] = {
    val keys = jso.keys

    val wellTyped = {
      ( keys("type"), keys("internalType") ) match {
        case (  true,  true ) => JsSuccess( jso )
        case (  true, false ) => JsSuccess( jso + ( "internalType", jso.value("type" ) ) )
        case ( false,     _ ) => JsError( s"An abi ${parentName} parameter must contain a 'type'. Bad json: ${jso}" )
      }
    }

    nonTypeParams.foldLeft( wellTyped : JsResult[JsObject]) { case ( accum : JsResult[JsObject], Tuple2( key : String, mbDefault : Option[JsValue] ) ) =>
      accum.flatMap { obj =>
        ( keys(key), mbDefault ) match {
          case ( true,          _ ) => JsSuccess( obj )
          case ( false, Some(jsv) ) => JsSuccess( obj + Tuple2( key, jsv ) )
          case ( false,      None ) => JsError( s"An abi ${parentName} parameter must contain '${key}' and no default is available. Bad json: ${jso}" )
        }
      }
    }
  }

  private def restrictTransformAbiConstructorParameterValue( jsv : JsValue ) : JsResult[JsObject] = {
    restrictTransformAbiXxxParameterValue( "constructor", Map( "name" -> None ) )( jsv )
  }

  private def restrictTransformAbiFunctionParameterValue( jsv : JsValue ) : JsResult[JsObject] = {
    restrictTransformAbiXxxParameterValue( "function", Map( "name" -> None ) )( jsv )
  }

  private def restrictTransformAbiEventParameterValue( jsv : JsValue ) : JsResult[JsObject] = {
    restrictTransformAbiXxxParameterValue( "event", Map( "name" -> None, "indexed" -> None ) )( jsv )
  }

  private def restrictTransformAbiFunctionValue( jsv : JsValue ) : JsResult[JsObject] = {
    jsv match {
      case jso : JsObject => restrictTransformAbiFunctionObject( jso )
      case oops           => JsError( s"An abi function must be a JsObject, found $oops" )
    }
  }

  private def restrictTransformAbiFunctionObject( jso : JsObject ) : JsResult[JsObject] = {

    val keys = jso.keys

    // these keys required for all versions
    val requiredKeys = "name" :: "inputs" :: "outputs" :: "type" :: Nil

    def requiredKeysCheck = requiredKeys.foldLeft( None : Option[JsResult[JsObject]] ) { ( nascent, next ) =>
      nascent match {
        case Some( _ ) => nascent
        case None      => if (!keys(next)) Some( JsError(s"Required key '${next}' for ABI function not found.") ) else None
      }
    }

    def constantFromConstant : Option[Boolean] = jso.value.get("constant").map( _.asInstanceOf[JsBoolean].value )

    def constantFromStateMutability : Option[Boolean] = {
      jso.value.get("stateMutability").map( _.asInstanceOf[JsString].value ) match {
        case Some( "pure" ) | Some( "view" ) => Some( true  )
        case Some( _ )                       => Some( false )
        case None                            => None
      }
    }

    def constantValue : Boolean = {
      ( constantFromConstant, constantFromStateMutability ) match {
        case ( Some( c ), None )           => c
        case ( None, Some( c ) )           => c
        case ( Some( cfc ), Some( cfsm ) ) => if ( cfc == cfsm ) cfc else throw new BadAbiException( s"Contains inconsistent 'constant' and 'stateMutability' values: ${jso}" )
        case ( None, None )                => false // stateMutability is specified as defaulting to 'nonpayable'
      }
    }

    def payableValue  : Boolean = jso.value("payable").asInstanceOf[JsBoolean].value

    // TODO: simplify this logic, since stateMutabiity is now defined to default to 'nonpayable', so stateMutability is always in some sense available
    def informalAbiVersion = {
      val hasPayable         = keys("payable")
      val hasStateMutability = keys("stateMutability")

      (hasPayable, hasStateMutability) match {
        case ( false, false ) => 1
        case ( true, false  ) => 2
        case ( true, true   ) => 3
        case ( false, true  ) => 4 // we're required to fill in the payable field from stateMutability
      }
    }
    def constructBaseObject : JsObject = {
      requiredKeys.foldLeft(JsObject(Nil)){ ( nascent, next ) => nascent + (next, jso.value(next)) }
    }
    def augmentForInformalAbiVersion( informalAbiVersion : Int )( baseObject : JsObject ) : JsResult[JsObject] = {
      informalAbiVersion match {
        case 1 => {
          if ( constantValue ) {
            JsSuccess[JsObject]( baseObject + ("payable", JsBoolean( false )) + ("constant", JsBoolean(constantValue)) + ("stateMutability", JsString("view")) )
          } else {
            // stateMutability now specified to default to nonpayable, may break interpretation of very old contract abis (before payable was defined)
            JsSuccess[JsObject]( baseObject + ("payable", JsBoolean( false )) + ("constant", JsBoolean(constantValue)) + ("stateMutability", JsString("nonpayable")) ) 
          }
        }
        case 2 => {
          if ( payableValue ) {
            JsSuccess[JsObject]( baseObject + ("payable", JsBoolean( true )) + ("constant", JsBoolean(constantValue)) + ("stateMutability", JsString("payable")) )
          }
          else {
            if (constantValue) {
              JsSuccess[JsObject]( baseObject + ("payable", JsBoolean( false )) + ("constant", JsBoolean(constantValue)) + ("stateMutability", JsString("view")) ) // we can't guarantee pure, so we call this view
            }
            else {
              JsSuccess[JsObject]( baseObject + ("payable", JsBoolean( false )) + ("constant", JsBoolean(constantValue)) + ("stateMutability", JsString("nonpayable")) )
            }
          }
        }
        case 3 => {
          JsSuccess[JsObject]( Seq( "payable", "stateMutability" ).foldLeft( baseObject ){ ( nascent, next ) => nascent + ( next, jso.value(next) ) } + ("constant", JsBoolean(constantValue) ) )
        }
        case 4 => {
          val sm = jso.value("stateMutability").asInstanceOf[JsString]
          JsSuccess[JsObject]( baseObject + ("payable", JsBoolean( sm.value == "payable" )) + ("stateMutability", sm) + ("constant", JsBoolean(constantValue)) )
        }
        case _ => throw new InternalError("Unexpected 'Informal ABI Version', this should never happen!")
      }
    }
    requiredKeysCheck.getOrElse( augmentForInformalAbiVersion( informalAbiVersion )( constructBaseObject ) )
  }

  private def rd[T]( spec : (String,Option[JsValue])* )( inner : Format[T] ) : Format[T] = new RestrictingDefaultingFormat( spec.toMap )( inner )

  implicit val TightAbiFunctionParameterFormat    = new RestrictTransformingFormat( Seq( restrictTransformAbiFunctionParameterValue ) )                  ( Json.format[TightAbi.Function.Parameter]    )
  implicit val TightAbiFunctionFormat             = new RestrictTransformingFormat( Seq( restrictTransformAbiFunctionValue ) )                           ( Json.format[TightAbi.Function]              )
  implicit val TightAbiEventParameterFormat       = new RestrictTransformingFormat( Seq( restrictTransformAbiEventParameterValue ) )                     ( Json.format[TightAbi.Event.Parameter]       )
  implicit val TightAbiEventFormat                = rd( "name" -> None, "inputs" -> None, "anonymous" -> DefaultFalse, "type" -> None )                  ( Json.format[TightAbi.Event]                 )
  implicit val TightAbiConstructorParameterFormat = new RestrictTransformingFormat( Seq( restrictTransformAbiConstructorParameterValue ) )               ( Json.format[TightAbi.Constructor.Parameter] )
  implicit val TightAbiConstructorFormat          = rd( "inputs" -> None, "payable" -> DefaultTrue, "stateMutability" -> DefaultPayable, "type" -> None )( Json.format[TightAbi.Constructor]           )
  implicit val TightAbiReceiveFormat              = rd( "stateMutability" -> DefaultPayable, "type" -> None )                                            ( Json.format[TightAbi.Receive]               )
  implicit val TightAbiFallbackFormat             = rd( "payable" -> DefaultTrue, "stateMutability" -> DefaultPayable, "type" -> None )                  ( Json.format[TightAbi.Fallback]              )

  // these we'll have to do ourselves
  implicit val TightAbiFormat : Format[TightAbi] = new Format[TightAbi] {
    def reads( jsv : JsValue ) : JsResult[TightAbi] = {
      jsv match {
        case jsa : JsArray => {
          val ( functions, events, constructors, receive, fallback, message ) = {
            def accumulate(
              tuple : Tuple6[List[JsValue],List[JsValue],List[JsValue],Option[JsValue],Option[JsValue],Option[String]],
              elem : JsValue
            ) : Tuple6[List[JsValue],List[JsValue],List[JsValue],Option[JsValue],Option[JsValue],Option[String]] = {
              val ( fs, es, cs, r, fb, m ) = tuple
              m match {
                case Some( _ ) => ( fs, es, cs, r, fb, m )
                case None      => {
                  try {
                    (elem \ "type").get.as[String] match {
                      case "function"    => ( elem :: fs, es, cs, r, fb, m )
                      case "event"       => ( fs, elem :: es, cs, r, fb, m )
                      case "constructor" => ( fs, es, elem :: cs, r, fb, m )
                      case "receive"    => {
                        r match {
                          case Some( _ ) => ( fs, es, cs, r, fb, Some( s"Two receives found, only one permitted: $jsa" ) )
                          case None      => ( fs, es, cs, Some( elem ), fb, m )
                        }
                      }
                      case "fallback"    => {
                        fb match {
                          case Some( _ ) => ( fs, es, cs, r, fb, Some( s"Two fallbacks found, only one permitted: $jsa" ) )
                          case None      => ( fs, es, cs, r, Some( elem ), m )
                        }
                      }
                      case unexpected    => ( fs, es, cs, r, fb, Some( s"Unexpected element type in ABI: $unexpected" ) )
                    }
                  } catch {
                    case nse : NoSuchElementException => ( elem :: fs, es, cs, r, fb, m ) // spec says default is function
                  }
                }
              }
            }
            jsa.value.foldLeft( ( Nil, Nil, Nil, None, None, None ) : Tuple6[List[JsValue],List[JsValue],List[JsValue],Option[JsValue],Option[JsValue],Option[String]] ) ( accumulate )
          }
          message match {
            case None => {
              val abi = TightAbi( functions.reverse.map( _.as[TightAbi.Function] ), events.reverse.map( _.as[TightAbi.Event] ), constructors.reverse.map( _.as[TightAbi.Constructor] ), receive.map( _.as[TightAbi.Receive] ), fallback.map( _.as[TightAbi.Fallback] ) )
              JsSuccess( abi )
            }
            case Some( words ) => JsError( words )
          }
        }
        case _ => JsError( s"abi is expected as a JsArray, found ${jsv}" )
      }
    }
    def writes( definition : TightAbi ) : JsValue = {
      def makeFunction( abif : TightAbi.Function )       = Json.toJson(abif).asInstanceOf[JsObject] + ( "type", JsString("function") )
      def makeEvent( abie : TightAbi.Event )             = Json.toJson(abie).asInstanceOf[JsObject] + ( "type", JsString("event") )
      def makeConstructor( abic : TightAbi.Constructor ) = Json.toJson(abic).asInstanceOf[JsObject] + ( "type", JsString("constructor") )
      def makeReceive( abir : TightAbi.Receive )         = Json.toJson(abir).asInstanceOf[JsObject] + ( "type", JsString("receive") )
      def makeFallback( abifb : TightAbi.Fallback )      = Json.toJson(abifb).asInstanceOf[JsObject] + ( "type", JsString("fallback") )
      JsArray(
        immutable.Seq.empty[JsValue] ++ definition.functions.map( makeFunction ) ++ definition.events.map( makeEvent ) ++ definition.constructors.map( makeConstructor ) ++ definition.receive.toSeq.map( makeReceive )++ definition.fallback.toSeq.map( makeFallback )
      )
    }
  }


  def apply( json : String ) : TightAbi = Json.parse( json ).as[TightAbi]
  val empty = TightAbi( immutable.Seq.empty, immutable.Seq.empty, immutable.Seq.empty, None, None )

  final object Function {
    case class Parameter( name : String, `type` : String, internalType : String ) extends TightAbi.Parameter
  }
  final case class Function( name : String, inputs : immutable.Seq[Function.Parameter], outputs : immutable.Seq[Function.Parameter], constant : Boolean, payable : Boolean, stateMutability : String )

  final object Constructor {
    val noArgNoEffect = Constructor( Nil, false, "pure" )
    case class Parameter( name : String, `type` : String, internalType : String ) extends TightAbi.Parameter
  }
  final case class Constructor( inputs : immutable.Seq[Constructor.Parameter], payable : Boolean, stateMutability : String )

  final object Event {
    final case class Parameter( name : String, `type` : String, indexed : Boolean, internalType : String ) extends TightAbi.Parameter
  }
  final case class Event( name : String, inputs : immutable.Seq[Event.Parameter], anonymous : Boolean )

  final case class Receive( stateMutability : String ) {
    require( stateMutability == "payable", s"Receive functions should always have stateMutability 'payable', found '${stateMutability}'." )
  }

  final case class Fallback( payable : Boolean, stateMutability : String ) {
    def this( payable : Boolean ) = this( payable, if (payable) "payable" else "nonpayable" )
  }

  sealed trait Parameter {
    val name : String
    val `type`  : String
    val internalType : String
    def tpe = `type`
  }

  private final object StandardSort {
    import Ordering.Implicits._
    implicit val Ordering_FunctionParameter = Ordering.by( (fp : Function.Parameter) => (fp.name, fp.`type`, fp.internalType) )
    implicit val Ordering_ConstructorParameter = Ordering.by( (cp : Constructor.Parameter) => (cp.name, cp.`type`, cp.internalType) )
    implicit val Ordering_EventParameter = Ordering.by( (ep : Event.Parameter) => (ep.name, ep.`type`, ep.internalType, ep.indexed) )
    implicit val Ordering_Function = Ordering.by( (fcn : Function) => ( fcn.name, fcn.inputs, fcn.outputs, fcn.constant, fcn.payable, fcn.stateMutability ) )
    implicit val Ordering_Constructor = Ordering.by( (ctor : Constructor) => ( ctor.inputs, ctor.payable, ctor.stateMutability ) )
    implicit val Ordering_Event = Ordering.by( (ev : Event) => ( ev.name, ev.inputs, ev.anonymous ) )

    def apply( abi : TightAbi ) : TightAbi = TightAbi( abi.functions.sorted, abi.events.sorted, abi.constructors.sorted, abi.receive, abi.fallback )
  }
}
final case class TightAbi(
  functions : immutable.Seq[TightAbi.Function],
  events : immutable.Seq[TightAbi.Event],
  constructors : immutable.Seq[TightAbi.Constructor],
  receive : Option[TightAbi.Receive],
  fallback : Option[TightAbi.Fallback]
) extends MaybeEmpty {
  def isEmpty : Boolean = functions.isEmpty && events.isEmpty && constructors.isEmpty && receive == null && fallback == null
  def withStandardSort : TightAbi = TightAbi.StandardSort.apply( this )
}

